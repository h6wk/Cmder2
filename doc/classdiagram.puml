@startuml





/' Objects '/

class scoped_logger {
	+scoped_logger(const std::string& className, const char* funcName, unsigned line)
	+~scoped_logger()
	-_ss : std::stringstream
	+stream() : std::stringstream&
}


namespace cmder {
	abstract class IControllableThread {
		+{abstract} getStatus() : int {query}
		+{abstract} start() : void
		+{abstract} stop() : void
	}

	abstract class IStatProvider {
		+{abstract} statNotification(const std::string& notificationName) : uint64_t {query}
	}

	enum Status {
		Init
		Run
		Start
		Stop
	}

	namespace tst {
		class CallbackTest {
			#{static} sCallback : static Callback::SharedPtr
			#SetUp() : void
			#{static} SetUpTestSuite() : void
			#{static} TearDownTestSuite() : void
		}

		class TaskTest {
			#SetUp() : void
			#{static} SetUpTestSuite() : void
			#TearDown() : void
			#{static} TearDownTestSuite() : void
		}

		class ThreadPoolTest {
			#mThreadPool : std::unique_ptr<ThreadPool>
			#SetUp() : void
			#{static} SetUpTestSuite() : void
			#TearDown() : void
			#{static} TearDownTestSuite() : void
		}
	}

	namespace tools {
		class ThreadPool {
			+ThreadPool(size_t threadCount)
			-function<void()
			+~ThreadPool()
			-mStopThreadPool : bool
			+result_of_t<F(Args ... )>>execute ( F&& f, Args&& ... args) : requires std::invocable<F , Args ...>
			-mConditionVariable : std::condition_variable
			-mMutex : std::mutex
			-mThreads : std::vector<std::thread>
		}
	}

	namespace common {
		class Callback {
			+Callback(const std::string& owner)
			+~Callback()
			+empty() : bool {query}
			-mMutex : mutable std::mutex
			+size() : size_t {query}
			+operator<<(std::ostream& ostr, const Callback::SharedPtr& cb) : std :: ostream&
			-mConditionVariable : std::condition_variable
			+pop() : std::optional<Message_t>
			+tryPop() : std::optional<Message_t>
			-mMessages : std::queue<Message_t>
			-mOwnerName : std::string
			+clear() : void
			+notify(TaskId_t taskId, CallbackMessageType_t type, const std::string& message) : void
		}

		enum CallbackMessageType_t {
			NOTIFICATION
			RESULT
		}

		enum ExecutionMode_t {
			Async
			Blocking
		}

		class Callback::Message_t {
			+mType : CallbackMessageType_t
			+mTime : ChronoTime_t
			+mTaskId : TaskId_t
			+mText : std::string
		}
	}

	namespace agent {
		class Receipt {
			+Receipt(ExecutionMode_t mode)
			-mEndTime : ChronoTime_t
			-mStartTime : ChronoTime_t
			+getEndTime() : ChronoTime_t& {query}
			+getStartTime() : ChronoTime_t& {query}
			+getExecutionMode() : ExecutionMode_t {query}
			-mStatus : Status_t
			+getTaskId() : TaskId_t {query}
			-mMode : const ExecutionMode_t
			-mTaskId : const TaskId_t
			+getStatus() : int {query}
			+setEndTime() : void
			+setStatus(Status_t status) : void
		}

		class Task {
			-mTaskConfiguration : std::vector<TaskConfig>
		}

		enum Receipt::Status_t {
			FAIL
			OK
		}

		enum TaskName {
			BlockMe_3s
			Pi
			PingMe_5x
		}

		class Task::TaskConfig {
		}
	}
}





/' Inheritance relationships '/




/' Aggregation relationships '/

cmder.common.Callback::Message_t *-- cmder.common.CallbackMessageType_t


cmder.tst.CallbackTest *-- cmder.common.Callback


cmder.agent.Receipt *-- cmder.common.ExecutionMode_t


cmder.tst.ThreadPoolTest *-- cmder.tools.ThreadPool






/' Nested objects '/

cmder.common.Callback +-- cmder.common.Callback::Message_t


cmder.agent.Receipt +-- cmder.agent.Receipt::Status_t


cmder.agent.Task +-- cmder.agent.Task::TaskConfig




@enduml
